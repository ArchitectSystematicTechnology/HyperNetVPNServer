#!/bin/sh
# Start the {{ item.service }}-{{ item.container.name }} container.

{# The purpose of this file is to generate a nice, readable shell script, that
   can be inspected on the resulting system. Due to the issues with whitespace
   handling in Jinja, we programatically build an options list, and dump it
   at once at the end - the resulting template looks a lot like code.
#}

{# Define a global namespace, and a macro to add options to it #}
{%- set g = namespace(
               options=[],
               has_custom_tmp_volume=False)
-%}
{%- macro opt(name, value) -%}
  {{ g.options.append('--%s=%s' % (name, value)) }}
{%- endmacro -%}
{%- if item.container.docker_options is defined -%}
  {{ g.options.append(item.container.docker_options) }}
{%- endif -%}

{{ opt('network', 'host') }}

{# Environment variables #}
{% for k, v in item.container.get('env', {}) | dictsort %}
  {{ opt('env', '%s=%s' % (k, v | quote)) }}
{% endfor %}

{# Port configuration, and bind mounts #}
{% if item.container.get('ports', []) %}
  {% for port in item.container.get('ports',[]) %}
    {{ opt('expose', port) }}
  {% endfor %}
{% elif item.container.get('port') %}
  {{ opt('expose', item.container.port) }}
{% endif %}

{# Define mountpoints / volumes. We treat /tmp specially as the container
   configuration might override it. To detect if one of the mounts is a
   /tmp mount, and propagate the result outside of the loop, we have to
   use a special "jinja namespace" variable - see the discussion on
   assignment scope at https://jinja.palletsprojects.com/en/2.11.x/templates/#assignments
#}
{% for mount in item.container.get('volumes', []) %}
  {% for k, v in mount.items() %}
    {% if v == '/tmp' %}
      {% set g.has_custom_tmp_volume = True %}
    {% endif %}
    {% if k == 'tmpfs' -%}
      {{ opt('mount', 'type=tmpfs,destination=%s,tmpfs-mode=01777,tmpfs-size=64M' % v) }}
    {% else -%}
      {{ opt('mount', 'type=bind,source=%s,destination=%s' % (k, v)) }}
    {% endif %}
  {% endfor %}
{% endfor %}

{# System-level volumes that all containers have.
   Include by default tmpfs mounts for standard Debian locations (/tmp,
   /run/lock), and a bind mount for the syslog socket in /dev/log. #}
{{ opt('mount', 'type=tmpfs,destination=/run/lock,tmpfs-mode=01777,tmpfs-size=16M') }}
{{ opt('mount', 'type=bind,source=/dev/log,destination=/dev/log') }}
{% if not g.has_custom_tmp_volume %}
  {{ opt('mount', 'type=tmpfs,destination=/tmp,tmpfs-mode=01777,tmpfs-size=64M') }}
{% endif %}

{# Mount the service credentials inside the container. #}
{% for creds in services[item.service].get('service_credentials', []) %}
  {{ opt('mount', 'type=bind,source=/etc/credentials/x509/' + creds.name + ',destination=/etc/credentials/x509/' + creds.name) }}
{% endfor %}

{# Security options (unless root=True) #}
{% if item.container.get('drop_capabilities', not item.container.get('root')) %}
  {{ opt('security-opt', 'no-new-privileges') }}
  {{ opt('cap-drop', 'all') }}
{% endif %}

{# The following are options that are set at runtime, we can't use template machinery #}
opts=
# Optionally mount the OpenCensus tracing config in the container.
if [ -d /etc/tracing ]; then
  opts="$opts --mount=type=bind,source=/etc/tracing,destination=/etc/tracing"
fi

{% if not item.container.get('root') %}
# Run as unprivileged user.
container_uid=$(id -u docker-{{ item.service }})
container_gid=$(id -g docker-{{ item.service }})
opts="$opts --user=$container_uid:$container_gid"
# Add additional groups that the user is a member of.
for gid in $(id -G docker-{{ item.service }}); do
    if [ $gid -ne $container_gid ]; then
        opts="$opts --group-add=$gid"
    fi
done
{% endif %}

{% if container_runtime == 'podman' %}
# Remove 'created' (but never started) and 'exited' containers to avoid name conflicts
podman ps --quiet --all \
  --filter status=created \
  --filter name={{ item.service }}-{{ item.container.name }} \
  | xargs --no-run-if-empty podman rm

podman ps --quiet --all \
  --filter status=exited \
  --filter name={{ item.service }}-{{ item.container.name }} \
  | xargs --no-run-if-empty podman rm

exec /usr/bin/podman run \
  --cgroup-manager=cgroupfs \
  --cgroup-parent /system.slice/docker-{{ item.tag }}.service \
  --rm --name {{ item.service }}-{{ item.container.name }} \
  $opts \
{% for opt in g.options %}
  {{ opt }} \
{% endfor %}
  {{ item.container.image }} {{ item.container.get('args', '') }}
{% elif container_runtime == 'docker' %}
exec /usr/bin/systemd-docker --env run \
  --rm --name {{ item.service }}-{{ item.container.name }} \
  $opts \
{% for opt in g.options %}
  {{ opt }} \
{% endfor %}
  {{ item.container.image }} {{ item.container.get('args', '') }}
{% endif %}
