#!/bin/sh
# Start the {{ item.service }}-{{ item.container.name }} container.

{# The purpose of this file is to generate a nice, readable shell script, that
   can be inspected on the resulting system. Due to the issues with whitespace
   handling in Jinja, we programatically build an options list, and dump it
   at once at the end - the resulting template looks a lot like code.
#}

{# Define a global namespace, and a macro to add options to it #}
{%- set g = namespace(
               options=[],
               has_custom_tmp_volume=False)
-%}
{%- macro opt(name, value=None) -%}
{% if value is not none -%}
  {{ g.options.append('--%s=%s' % (name, value)) }}
{% else -%}
  {{ g.options.append('--%s' % name) }}
{% endif -%}
{%- endmacro -%}
{%- if item.container.docker_options is defined -%}
  {{ g.options.append(item.container.docker_options) }}
{%- endif -%}

{{ opt('network', 'host') }}

{# Environment variables #}
{% for k, v in item.container.get('env', {}) | dictsort %}
  {{ opt('env', '%s=%s' % (k, v | quote)) }}
{% endfor %}

{# Port configuration #}
{% if item.container.get('ports', []) %}
  {% for port in item.container.get('ports',[]) %}
    {{ opt('expose', port) }}
  {% endfor %}
{% elif item.container.get('port') %}
  {{ opt('expose', item.container.port) }}
{% endif %}

{# Root read-only? #}
{% if item.container.get('readonly', True) %}
  {{ opt('read-only') }}
  {# podman will mount /run /tmp and /var/tmp with writable tmpfs when
     the --read-only option is specified (see --read-only-tmpfs), so 
     do not add our own /tmp mount #}
  {% set g.has_custom_tmp_volume = True %}
{% endif %}

{# Define mountpoints / volumes. We treat /tmp specially as the container
   configuration might override it. To detect if one of the mounts is a
   /tmp mount, and propagate the result outside of the loop, we have to
   use a special "jinja namespace" variable - see the discussion on
   assignment scope at https://jinja.palletsprojects.com/en/2.11.x/templates/#assignments
#}
{% for mount in item.container.get('volumes', []) %}
  {% for k, v in mount.items() %}
    {% if v == '/tmp' %}
      {% set g.has_custom_tmp_volume = True %}
    {% endif %}
    {% if k == 'tmpfs' -%}
      {{ opt('mount', 'type=tmpfs,destination=%s,tmpfs-mode=01777,tmpfs-size=64M' % v) }}
    {% else -%}
      {{ opt('mount', 'type=bind,source=%s,destination=%s' % (k, v)) }}
    {% endif %}
  {% endfor %}
{% endfor %}

{# System-level volumes that all containers have.
   Include by default tmpfs mounts for standard Debian locations (/tmp,
   /run), and a bind mount for the syslog socket in /dev/log. #}
{{ opt('mount', 'type=tmpfs,destination=/run,tmpfs-mode=01777,tmpfs-size=16M,noexec=false,notmpcopyup') }}
{% if not g.has_custom_tmp_volume %}
  {{ opt('mount', 'type=tmpfs,destination=/tmp,tmpfs-mode=01777,tmpfs-size=64M,notmpcopyup') }}
{% endif %}
{{ opt('mount', 'type=bind,source=/dev/log,destination=/dev/log') }}
{{ opt('mount', 'type=bind,source=/etc/credentials/system,destination=/etc/ssl/certs') }}

{# Mount the service credentials inside the container. #}
{% for creds in services[item.service].get('service_credentials', []) %}
  {%- set credentials_path='/etc/credentials/' + (creds.ca_tag | default('x509')) + '/' + creds.name %}
  {{ opt('mount', 'type=bind,source=' + credentials_path + ',destination=' + credentials_path) }}
{% endfor %}

{# Security options (unless root=True) #}
{% if item.container.get('drop_capabilities', not item.container.get('root')) %}
  {{ opt('security-opt', 'no-new-privileges') }}
  {{ opt('cap-drop', 'all') }}
{% endif %}

{# The following are options that are set at runtime, we can't use template machinery #}
opts=
# Optionally mount the OpenCensus tracing config in the container.
if [ -d /etc/tracing ]; then
  opts="$opts --mount=type=bind,source=/etc/tracing,destination=/etc/tracing"
fi

{% if not item.container.get('root') %}
# Run as unprivileged user.
container_uid=$(id -u {{ services[item.service].user }})
container_gid=$(id -g {{ services[item.service].user }})
opts="$opts --user=$container_uid:$container_gid"
# Add additional groups that the user is a member of.
for gid in $(id -G {{ services[item.service].user }}); do
    if [ $gid -ne $container_gid ]; then
        opts="$opts --group-add=$gid"
    fi
done
{% endif %}


# TODO: move to --log-driver=passthrough once it is supported
# by the Podman version in Debian stable, and then add the -d
# option to get rid of the useless 'podman' process.
{% if container_runtime == 'podman' %}
exec /usr/bin/podman run \
  --cgroups=disabled \
  --replace \
  --sdnotify=conmon \
{% elif container_runtime == 'docker' %}
exec /usr/bin/systemd-docker --env run \
{% endif %}
  --rm --name {{ item.service }}-{{ item.container.name }} \
  --pull=never \
  --log-driver=none \
  --no-healthcheck \
  $opts \
{% for opt in g.options %}
  {{ opt }} \
{% endfor %}
  "$@" \
  {{ item.container.image }} {{ item.container.get('args', '') }}
