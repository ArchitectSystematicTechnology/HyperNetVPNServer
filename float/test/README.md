Float Integration Tests
===

The float integration test suite is meant to verify the basic
functionality of the builtin services. Its main purpose is to verify,
at the end of a setup process (generally as part of a CI environment),
that the target infrastructure is operating as expected.

To avoid requiring complex dependencies on the management host, the
test suite is packaged as a container, and it is then run on the
target hosts themselves. The test suite is built as a series of Python
unit tests, and the container image just invokes them sequentially.

The test suite comes with a simple Ansible playbook, which performs
the following steps:

* it dumps the float configuration into a temporary file, so that the
  test suite can read it (to find which services are running, on
  which hosts, etc);
* it pulls the latest version of the container image;
* it runs the test suite.

This playbook is targeted for the test environments generated by
"float create-env", specifically because it expects to find a host
named *host1*, and the default test admin credentials
(admin/password). If this is not the case, it should be easy to
customize the playbook according to your specific environment.

## Checks performed by the integration test

* Verify that all public endpoints for built-in services are
  reachable, even those behind authentication. There is no test of
  functionality, just that the response HTTP status code is 200.
* Verify that no monitoring alerts are currently firing (no firint
  alerts with severity=page).

# Running tests in a CI environment

A very common CI test pattern is to test a specific configuration on
short-lived ephemeral virtual machines created for this purpose. Such
a test job should perform (at least) the following steps:

* Generate, or provide somehow, an environment configuration to be
  used for the test. This is the primary purpose of the *float
  create-env* command, which exposes many parameters of the VM setup
  as command-line parameters. On the other hand, if your setup is
  completely static, you can also just use a pre-created test
  environment configuration somewhere in your repository. An example
  (assuming you have *float* in the PATH, and that you intend to
  create a new test configuration in the *test-1* directory, running 3
  hosts):

```shell
float create-env --domain=example.com --num-hosts=3 test-1
```

* Initialize test credentials by running the *init-credentials.yml*
  playbook.

```shell
cd test-1 && float run init-credentials.yml
```

* Start the virtual machines that constitute the test targets, whose
  configuration was likely generated as part of step 1. The details
  are going to depend on which specific technology you are using for
  VM management. Float creates a Vagrant configuration by default, so
  if you're using Vagrant, this is simply:

```shell
cd test-1 && vagrant up
```

* Run your main playbook to configure the VMs:

```shell
cd test-1 && float run site.yml
```

* Run the integration tests:

```shell
cd test-1 && float run /path/to/float/test/integration-test-docker.yml
```

* Stop the virtual machines used for the test, regardless of its result:

```shell
cd test-1 && vagrant destroy -f
```

### How to make CI run (somewhat) faster

Ansible, at least the way float uses it, can be frustratingly
slow. This is even more of a problem in a CI context, where the
feedback latency can be quite annoying. There's a limit to what can be
done, as most of the slowness is intrinsic in the choice of Ansible as
the implementation layer, but there are a number of things that can be
done to bring down the execution time to more reasonable values. In
order of importance:

1. Install
   [Mitogen](https://mitogen.networkgenomics.com/ansible_detailed.html).
   There is really no reason why you wouldn't, it magically and
   transparently makes Ansible *significantly* faster (5-10 times in
   our tests). To enable it, you'll need to modify the *strategy*
   setting in the Ansible configuration, either manually or by passing
   `-e ansible_cfg.defaults.strategy=mitogen_linear` to float
   create-env.
2. Give test environments appropriate resources. For starters, make
   sure you have fast disks for the virtual machines: the float setup
   does a lot of I/O, due to the package installations and the setup
   of container images. Also ensure that the management host (the one
   running Ansible, usually the CI runner itself) is not CPU-bound.
3. Set up an APT cache (for instance with *apt-cacher-ng*). Set the
   Ansible variable *apt_proxy* to the host:port of the cache, or pass
   the `-e config.apt_proxy=HOST:PORT` option to float create-env.
4. Quite a bit of time is spent downloading container images from
   float's registry, so using some sort of Docker registry cache could
   help. Most caching methods will require a MitM SSL CA, which can be
   set up using the `podman_additional_ssl_ca` configuration
   variable. You can then set `podman_https_proxy` to the HOST:PORT
   address of your cache.

### Disabling the log database

Another approach to getting tests to run faster is to disable services
that are not needed. Among the set of built-in float services, a good
candidate is Elasticsearch / Kibana, the "database and visualization"
part of the log collection service: these are diagnostic tools with no
further dependencies, and since their associated container images are
very large, omitting them from the test environment will provide a
clear speed improvement.

This is, in fact, already the default for test environments created
with "float create-env" and it can be achieved by:

* importing "services.core.yml" instead of
  "services.default.yml" for the float built-in service definitions;
* setting the configuration variable "enable_elasticsearch" to false.

The resulting environment will still run the *log-collector* service,
but instead of storing logs in Elasticsearch, it will just dump them
locally below */var/log/remote*.
